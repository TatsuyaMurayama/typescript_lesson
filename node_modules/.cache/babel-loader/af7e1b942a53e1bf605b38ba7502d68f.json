{"ast":null,"code":"var _jsxFileName = \"/Users/tt-murayama/development/React/typescript_lesson/src/App.tsx\";\nimport React from 'react';\nimport './App.css';\nimport TestCompornent from './TestCompornent'; //typeofによる型継承を既存のJSONファイルに適用することで簡単に型を定義できる\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst name = \"hello\"; //型が\"hello\"になっている=リテラル型=>文字列リテラル\n\nconst name4 = \"hello\";\nlet name2 = \"hello\";\nlet username = \"Hello\"; //型推論でStringと推定されている\n\nlet username2 = \"Hello\"; // 明示的に型を指定する方法=annotation\n\nlet dummyNum = 2;\nlet test = true;\nlet test2 = true;\nlet array = [true, true, false];\nlet array2 = [true, true, false];\nlet array3 = [0, 2, \"3\"];\nlet array4 = [0, 2, \"3\"]; //オブジェクトの型の定義の仕方    interface=>オブジェクト\n\nlet nameObj = {\n  first: null\n}; //本来はfirstとlastの２つが必須\n//オブジェクトで作った型を用いて変数を作れる\n//nullを指定する場合はオブジェクトの型の指定でしておく\n//関数の書き方\n\nconst func1 = (x, y) => {\n  return x + y;\n}; //引数それぞれにも型を指定できるが、func1自体の返り値の型も指定できる\n//Intersection Types\n//複数のTypeを結合する処理\n\n\n//２つの定義したオブジェクトの型を結合\nconst userA = {\n  age: 30,\n  city: \"Tokyo\",\n  username: \"xxx\",\n  password: \"yyy\"\n}; //Union Types  変数が受け取れる型を制限するときに使う\n\nlet value;\nvalue = true;\nvalue = \"hello\"; //配列の要素に対してもUnion Typesを使うことができる\n\nlet arrayUni;\narrayUni = [0, 2, 4, \"hello\"]; //リテラル(Literal)とUnion Types の組み合わせ\n\nlet company;\ncompany = \"Amazon\";\nlet memory;\nmemory = 245; //typof 既に記載した型定義を継承することができる\n\nlet msg = \"Hi\";\nlet msg2;\nlet animal = {\n  cat: \"small cat\"\n};\nlet newAnimal = {\n  cat: \"big cat\"\n}; //これを使えば複数の同じ様な型を都度都度設定する必要がなく、１度でできる。\n//keyof\n\nlet key;\nkey = \"primary\"; //KEYSで指定されたKeyしか入力できない\n//typeof + keyof\n\nconst SPORTS = {\n  soccer: \"Soccer\",\n  baseball: \"Baseball\"\n};\nlet keySports; //typeofで指定された引数における、keyofで指定されたkeyの中の値しか入力できない\n\nkeySports = \"soccer\"; //ERROR\n//let keySports2: keyof SPORTS;\n//SPORTはconstで定義された関数であり、型ではないので使えない。そのため、型として取り出すためにtypeofがいる\n//enum(列挙型) 自動的に連番をつけてくれる\n\nvar OS;\n\n(function (OS) {\n  OS[OS[\"Windows\"] = 0] = \"Windows\";\n  OS[OS[\"Mac\"] = 1] = \"Mac\";\n  OS[OS[\"Linux\"] = 2] = \"Linux\";\n})(OS || (OS = {}));\n\nconst PC1 = {\n  id: 1,\n  OSType: OS.Windows\n};\nconst PC2 = {\n  id: 2,\n  OSType: OS.Mac\n}; //型の互換性\n\nconst comp1 = \"test\";\nlet comp2 = comp1; //string の中に文字列リテラルをいれるのはOK\n\nlet comp3 = \"test\"; //ERROR\n//let comp4: \"test\" = comp3;\n//同じ\"test\"でもStringという抽象度からくるものには入れられない\n\nlet funcComp1 = x => {};\n\nlet funcComp2 = x => {}; //データ型が異なるため、同じ引数の値でも代入はできない\n//funcComp1 = funcComp2\n//Generics ジェネリクス\n//propsで使われる\n\n\nconst gen0 = {\n  item: \"hello\"\n}; //interfaceによって用いる属性だけ、テンプレートの様に用意し、型を後で決めることができる\n//const gen1: GEN = { item: \"hello\"}; \n//型を指定しないとエラーになる\n\nconst gen2 = {\n  item: 12\n}; //defaultの型を指定することができる\n\nconst gen3 = {\n  item: \"hello\"\n}; //この様にdefaultを指定することで、型指定なしで作ることができる\n//extendsによる型制限\n\nconst gen4 = {\n  item: \"hello\"\n};\nconst gen5 = {\n  item: 23\n}; //const gen6: GEN2<boolean> ={item: true};\n//extendsで指定した制限以外なので使えない\n\nfunction funcGen(props) {\n  return {\n    item: props\n  };\n}\n\nconst gen6 = funcGen(\"test\");\nconst gen7 = funcGen(null);\n\nfunction funcGen1(props) {\n  return {\n    value: props\n  };\n}\n\nconst gen8 = funcGen1(\"hello\");\nconst gen9 = funcGen1(null); //extendsで指定した型以外を関数に入れられない\n//const gen10 = funcGen1(12);\n//propsの使い方\n\nfunction funcGen3(props) {\n  return {\n    value: props.price\n  };\n}\n\nconst gen10 = funcGen3({\n  price: 10\n});\n\nconst funcGen4 = props => {\n  return {\n    value: props.price\n  };\n}; //FC:Functional Compornent 関数コンポーネント\n\n\nconst App = () => {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: /*#__PURE__*/_jsxDEV(\"header\", {\n      className: \"App-header\",\n      children: /*#__PURE__*/_jsxDEV(TestCompornent, {\n        text: \"hello from App\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 209,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 208,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 207,\n    columnNumber: 5\n  }, this);\n};\n\n_c = App;\nexport default App; // function App() {\n//   return (\n//     <div className=\"App\">\n//       <header className=\"App-header\">\n//       </header>\n//     </div>\n//   );\n// }\n// export default App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"sources":["/Users/tt-murayama/development/React/typescript_lesson/src/App.tsx"],"names":["React","TestCompornent","name","name4","name2","username","username2","dummyNum","test","test2","array","array2","array3","array4","nameObj","first","func1","x","y","userA","age","city","password","value","arrayUni","company","memory","msg","msg2","animal","cat","newAnimal","key","SPORTS","soccer","baseball","keySports","OS","PC1","id","OSType","Windows","PC2","Mac","comp1","comp2","comp3","funcComp1","funcComp2","gen0","item","gen2","gen3","gen4","gen5","funcGen","props","gen6","gen7","funcGen1","gen8","gen9","funcGen3","price","gen10","funcGen4","App"],"mappings":"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","sourcesContent":["import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { ShorthandPropertyAssignment } from 'typescript';\n\n//JSONの型推論\nimport Data from \"./data.json\";\nimport TestCompornent from './TestCompornent';\n//typeofによる型継承を既存のJSONファイルに適用することで簡単に型を定義できる\ntype USERS = typeof Data;\n\n\nconst name = \"hello\"; //型が\"hello\"になっている=リテラル型=>文字列リテラル\nconst name4: string = \"hello\";\nlet name2 = \"hello\";\n\nlet username = \"Hello\"; //型推論でStringと推定されている\nlet username2: string = \"Hello\"; // 明示的に型を指定する方法=annotation\n\nlet dummyNum: number = 2;\n\nlet test = true;\nlet test2: boolean = true;\n\nlet array = [true, true, false];\nlet array2: boolean[] = [true, true, false];\nlet array3 = [0,2,\"3\"];\nlet array4: (string | number)[] = [0,2,\"3\"];\n\n//オブジェクトの型の定義の仕方    interface=>オブジェクト\ninterface NAME {\n  first: string | null;\n  last?: string; // ?を定義の後につけるとnullでもOKになる\n}\nlet nameObj: NAME = {first: null}; //本来はfirstとlastの２つが必須\n      //オブジェクトで作った型を用いて変数を作れる\n      //nullを指定する場合はオブジェクトの型の指定でしておく\n\n\n//関数の書き方\nconst func1 = (x:number, y:number): number => {\n  return x+y;\n}       //引数それぞれにも型を指定できるが、func1自体の返り値の型も指定できる\n\n\n\n//Intersection Types\n  //複数のTypeを結合する処理\ntype PROFILE ={\n  age:number;\n  city:string;\n};\ntype LOGIN ={\n  username:string;\n  password:string;\n};\ntype USER = PROFILE & LOGIN; //２つの定義したオブジェクトの型を結合\n\nconst userA: USER ={\n  age:30,\n  city:\"Tokyo\",\n  username: \"xxx\",\n  password: \"yyy\"\n}\n\n\n//Union Types  変数が受け取れる型を制限するときに使う\nlet value: boolean | string\nvalue = true;\nvalue = \"hello\";\n\n//配列の要素に対してもUnion Typesを使うことができる\nlet arrayUni: (number | string )[];\narrayUni = [0, 2, 4, \"hello\"];\n\n//リテラル(Literal)とUnion Types の組み合わせ\nlet company: \"FaceBook\" | \"Google\" | \"Amazon\";\ncompany = \"Amazon\";\n\nlet memory : 245 | 431;\nmemory = 245;\n\n//typof 既に記載した型定義を継承することができる\nlet msg: string = \"Hi\";\nlet msg2: typeof msg;\n\nlet animal = { cat: \"small cat\"};\nlet newAnimal : typeof animal = {cat: \"big cat\"};\n        //これを使えば複数の同じ様な型を都度都度設定する必要がなく、１度でできる。\n\n\n//keyof\ntype KEYS = {\n  primary: string;\n  secondary: string;\n};\nlet key: keyof KEYS\nkey = \"primary\";   //KEYSで指定されたKeyしか入力できない\n\n//typeof + keyof\nconst SPORTS = {\n  soccer: \"Soccer\",\n  baseball: \"Baseball\", \n};\n\nlet keySports: keyof typeof SPORTS; //typeofで指定された引数における、keyofで指定されたkeyの中の値しか入力できない\nkeySports = \"soccer\";\n\n//ERROR\n//let keySports2: keyof SPORTS;\n//SPORTはconstで定義された関数であり、型ではないので使えない。そのため、型として取り出すためにtypeofがいる\n\n\n//enum(列挙型) 自動的に連番をつけてくれる\nenum OS{\n  Windows,\n  Mac,\n  Linux,\n}\ninterface PC {\n  id: number,\n  OSType: OS;\n}\nconst PC1: PC = {\n  id:1,\n  OSType:OS.Windows,\n}\nconst PC2: PC ={\n  id: 2,\n  OSType:OS.Mac\n}\n\n//型の互換性\nconst comp1 = \"test\";\nlet comp2: string = comp1; //string の中に文字列リテラルをいれるのはOK\n\nlet comp3: string = \"test\";\n//ERROR\n//let comp4: \"test\" = comp3;\n//同じ\"test\"でもStringという抽象度からくるものには入れられない\n\nlet funcComp1 = (x: number) => {};\nlet funcComp2 = (x: string) => {};\n//データ型が異なるため、同じ引数の値でも代入はできない\n//funcComp1 = funcComp2\n\n\n\n//Generics ジェネリクス\n//propsで使われる\ninterface GEN<T>{\n  item: T;\n}\nconst gen0: GEN<string> = {item: \"hello\"};\n    //interfaceによって用いる属性だけ、テンプレートの様に用意し、型を後で決めることができる\n//const gen1: GEN = { item: \"hello\"}; \n    //型を指定しないとエラーになる\nconst gen2: GEN<number> = { item: 12};\n\n\n//defaultの型を指定することができる\ninterface GEN1<T = string>{\nitem: T;\n}\nconst gen3: GEN1 = {item: \"hello\"};\n    //この様にdefaultを指定することで、型指定なしで作ることができる\n\n//extendsによる型制限\ninterface GEN2<T extends string | number>{\n  item: T;\n} \nconst gen4: GEN2<string> ={item: \"hello\"};\nconst gen5: GEN2<number> ={item: 23};\n    //const gen6: GEN2<boolean> ={item: true};\n    //extendsで指定した制限以外なので使えない\n\nfunction funcGen<T>(props: T){\n  return {item: props}\n}\nconst gen6 = funcGen<string>(\"test\");\nconst gen7 = funcGen<string | null >(null);\n\nfunction funcGen1<T extends string | null>(props:T){\n  return {value: props};\n}\nconst gen8 = funcGen1(\"hello\");\nconst gen9 = funcGen1(null);\n//extendsで指定した型以外を関数に入れられない\n//const gen10 = funcGen1(12);\n\n//propsの使い方\ninterface Props{\n  price: number;\n}\nfunction funcGen3<T extends Props>(props: T){\n  return {value: props.price};\n}\nconst gen10 = funcGen3({ price: 10});\n\nconst funcGen4 = <T extends Props>(props: T) => {\n  return {value: props.price};\n}\n\n//FC:Functional Compornent 関数コンポーネント\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <TestCompornent text = \"hello from App\"/>\n      </header>\n    </div>\n  );\n}\nexport default App;\n\n\n\n\n// function App() {\n//   return (\n//     <div className=\"App\">\n//       <header className=\"App-header\">\n//       </header>\n//     </div>\n//   );\n// }\n\n// export default App;\n"]},"metadata":{},"sourceType":"module"}